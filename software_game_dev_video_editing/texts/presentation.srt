Salut à tous, j'espère que vous allez bien. Aujourd'hui je vous présente le projet Evil Death.

Evil Death est un jeu vidéo de zombies intense qui se déroule au cœur de l'Afrique subsaharienne. Le joueur principale est un soldat envoyé en mission pour rapporter un composé chimique afin de créer l'antidote pour guérir les infectés.

Voilà, c'est l'objectif du jeu en O de 1. Je me suis beaucoup inspiré du légendaire Resident Evil ainsi que d'autres jeux dans l'élaboration du gameplay de ce jeu.

Cela fait un moment déjà que je travail sur ce projet et jusqu'ici, j'ai implémenté le système de locomotion de base du joueur. La marche, la course, etc...

Donc, que pensez vous du rendu final? Donnez vos avis dans les commentaires. Si vous avez des idées ou des fonctionalités intéressantes pour le jeu, surtout ne vous gêner pas, cracher le morceau.

C'est bien d'écouter les idées des autres pour enrichir le développement du jeu. Maintenant, comment est-ce je suis parvenu à ce rendu final? Revenons au début du projet.

----------------------------------------------------------------------

Au début, je n'avais pas le joueur principal du jeu. Donc il fallait que j'en modélise un.
En fonction de l'objectif global du jeu, je devais modéliser un soldat militaire de A à Z.

Le problème, c'est que je ne suis pas aussi bon en scultage de personnage ou sur tout autre forme de scultage qui se rapproche de cela. Certe je suis désinateur mais je suis pas sculteur.

Il y a une très grande différence entre déssiner sur un papier en 2Dimension et sculter en 3Dimension. Il y a bien plus de paramètres à prendre en charge lorsqu'on sculte que lorsqu'on déssine simplement sur un papier ou tableau. Si vous voyez ce que je veux dire.

Je voulais certe faire le joueur, mais je ne voulais pas commencer avec un projet totalement vierge. Je voulais démarrer avec un modèle de base. Et c'est là que notre cher ami Sketchfab fait son entré. Je suis donc allez sur Sketchfab pour chercher une mesh de base sur laquelle le joueur final allait être modélisé.

Après de nombreuses recherches sur le site, j'ai fini par trouvé le modèle de base idéal pour faire mon joueur principal. C'est le modèle que vous voyez actuellement à l'écran. J'ai télécharger ce modèle que j'ai ensuite importer dans Blender pour pouvoir l'éditer.

La modélisation du joueur m'a pris une semaine, avec la retouche de la mesh d'origine, la génération des textures, des matériaux, etc... Je suis satisfait du résultat final. Petite précision, j'ai également chercher et télécharger d'autres modèles 3D que j'ai ensuite adaptés au context de la modélisation que je faisais.

Bah oui, je ne vais qu'en même me mettre à rebatir la houe, si elle est déjà existante et cadre avec mes attentes. Sinon à quoi sert le travail des modélisateurs (moi y compris) qui publient tous les jours leurs créations sur les platformes dédiées à cet effet.

Maintenant que nous avons notre joueur, il est temps de lui donné vie à travers des animations. Et c'est là que mixamo entre en scène.

-----------------------------------------------------------------------

Voici le service Mixamo. Il est fort probable que vous connaissiez déjà l'utilité de ce service. Mixamo m'a permis insérer le squelette d'animation ainsi que les animations du joueur de notre jeu. Ce service est libre d'accès, mais pas open source. Le lien est dans la description si vous voulez
accéder à ce service.

J'ai d'abord exporté mon joueur depuis Blender au format (.fbx) que j'ai ensuite importer dans Mixamo
afin de bénéficier de son système d'auto-rig.

Dès que mon joueur à acquis le squelette d'animation, je l'ai directement télécharger à son état
initial afin de pouvoir lui mettre toutes les animations que j'aurais télécharger de Mixamo dans
Blender.

Je me suis concentrer uniquement sur les animations dont j'avais besoin pour mettre en place le
système de locomotion de base du joueur. Il me fallait donc récolté les animations à utiliser pour
les cycles de la marche et de la course.

Lorsque j'ai eu toutes les animations dont-il me fallait, j'ai créer un nouveau projet Blender où
je les ai toutes importées grâce l'addon Mixamo-Root. Mixamo-Root est un plugin Blender permettant
d'ajouter un root bone à une animation. Root bone fait référence à l'os qui se trouve à la racine
de l'arbre qui définit le squelette d'animation tout entier du joueur).

Le root bone générer reprends les positions successives du hips bone. Pourquoi je vous raconte
toutes ces conneris? C'est parce que, une fois dans Godot, le joueur sera ratâcher à un objet central qui vas gérer les transformations du joueur dans l'espace 3D en fonction de ses animations.

Oui, oui j'avoue que ce que je viens de dire est trop technique, Mais patience, tout ça sera clair
pendant la programmation du déplacement dynamique du joueur synchrôniser à ses animations.

Le lien vers le plugin Blender Mixamo-Root est dans la description. A l'heure actuel, je n'utilise
plus ce addon parce qu'il présente des insuffisances lors de la projection des positions du hips
bone au root bone qu'il cré. Ce que je viens de dire est personnel. Peut-être que le mode de
fonctionnement de ce plugin comble vaux attentes.

Voici le résulat final après quelques heures de travail. J'ai donc due gérer le mouvement racine
(root motion en anglais) de toutes les animations mannuellement pour avoir le résulat que vous
voyez actuellement à l'écran.

Le mouvement racine est correctement synchrôniser à chaque animation. C'est très important de bien
extraire le mouvement racine de chaque animation. Cela facilitera ainsi le travail au script Godot
qui déplacera le joueur en fonction des positions et rotations du root bone récupérer de l'animation
en cours d'exécution.

Maintenant que nous avons les animations correctement configurées avec leur mouvement racine, il est
tant d'exporter tous ce bazard dans Godot.

---------------------------------------------------------------------------------------------------
J'ai commencé par d'abord exporté mon joueur au format (.glb), parce qu'avec ce format, on arrive
a avoir les textures, les matériaux et les animations lors des importations.

De plus, on a le WSIWAG. Le rendu actuel de Blender est ce qu'on obiendra sur Godot après 
importations si vous configurez bien le ShaderMaterial lorsque vous êtes en train de donner
un tint à votre modèle sur Blender.

Tout cela est supercool et pratique. Il y a encore d'autres avantages, notamment lors de la
compilation global du jeu. Mais je préfère rester bref pour l'instant. Si vous avez de
l'expérience avec d'autres formats, n'hésitez pas à le mensionner dans les commentaires.

J'ai exporté le joueur au format (.glb). Ensuite je l'ai importer dans Godot. Dans l'importateur
de Godot, j'ai extrait les textures, les objets, les matériaux et définir un Skeleton Map pour le
squelette d'animation du joueur.

Maintenant qu'on a notre joueur complètement immerger dans Godot, je suis revenu sur Blender.
Ensuite, j'ai exporté le rig qui contient tous les animations à utiliser pour réaliser le
système de locomotion de base de notre joueur.

Mon objectif dans l'exportation ici, est d'extraire les animations que renferme ce rig sous forme
d'une librairy d'animations une fois sur Godot. Cela me permettra de d'istinguer d'une part le 
modèle 3D du joueur avec son propre rig et d'autre part ces animations.

Grâce à cette manière d'organisation des ressources ou actifs : Appelé ça comme vous voulez, je
serai capable de reutiliser certaines animations de mon joueur sur d'autres modèles si besoin.

Donc, j'exporte ce rig au format (.glb) bien evidement. Ensuite je l'importe dans Godot toujours
avec le même process, mais cette fois çi, je m'assure de lui assigner le Skeleton Map du joueur
que j'ai créer lors de son importation.

Le Skeleton Map me permet de re-configurer le rig que je suis en train d'importer au rig original
du joueur pour que ce dernier puisse être en mesure de jouer correctement les animations que
détient ce rig. On n'appelle cela : Skeleton Retargeting ou Animations Retargeting pour reprendre
un terme plus courant.

C'est super important d'avoir un Skeleton Map sur le squelette d'animation de votre objet car
c'est lui qui représente la carte des os de votre squelette et c'est grâce à lui que vous serez
en mesure de jouer des animations appartenant à d'autres modèles riggé sur votre squelette 
d'animation.

Je tiens à préciser quelque chose. Assurez-vous que le rig où vous souhaitez recupérer les
animations ait une structure similaire au rig où vous voulez que les animations soient jouées.

Ce détail est très important pour éviter des comportements innatendu. Vous n'entenderez pas
ce que je viens de dire dans aucun tutoriel. C'est durant mes travaux que j'ai constaté cela.

Maintenant que nous avons nos animations importés et configurées sous forme de librairy
d'animations, testons si le re-ciblage de nos animations freshement importées marche sur
notre joueur.

Voilà, on voie clairement que notre joueur applique les animations. Tout ceci a été possible
parce que ces animations ont été extraites d'un rig qui est similaire à celui de notre joueur.
Je veux que vous gardez ce détail à l'esprit.

Après avoir tout fait, je me suis mis à configurer les StateMachine et BlendTree du joueur
afin de pourvoir être capable de contrôler ces états depuis un script Godot. En parlant d'état,
je fait allusion aux animations.

Voyez le StateMachine comme un diagramme d'état-transision en UML, où une animation représente
un état du joueur.

Bon, notre configuration des StateMachine est fait. A présent, je vais codé le comportement du
joueur et de tout ce qui va avec pour finalement être en mesure de manipuler notre joueur depuis
un clavier et une souris ou une manette de jeu.

---------------------------------------------------------------------------------------------------
J'ai d'abord commencé par implémenté le module de détection des entrées de l'utilisateur, parce
qu'avant tout, nous devons savoir quelle touche est appuyé afin de déduire quelle opération à
effectuer. Le module supporte les entrées de type clavier, souris, manette ainsi que les
combinaisons de touches. 

Viens ensuite notre cher RootMotion. Ce module écoute les viariations des positions et rotations
du RootBone enfin de déterminer la vélocité à appliqué sur le CharacterBody de notre joueur. C'est
ce que je disais lorsque je travailais sur les animations du joueur. C'est à ça que cela sert.
Tout ceci pour avoir un déplacement synchrônisé à l'animation en cours d'exécution.

Le module NC_BaseLocomotion fournit des fonctionnalités de base communes à la gestion de la
locomotion d'un joueur. Cette classe sera par la suite redéfinie par celles qui héritent
d'elle pour l'implémentation des fonctions propres à notre joueur.

IDEM pour les modules NC_DirectionalCycle, NC_StatesCycle et NC_PlayerMode. 

La plupard du temps, le joueur à sera amener à courir et à marcher. On aura donc le cycle de la
course et celui de la marche. D'où la mise en place des scripts running.gd et walking.gd. Ces 
scripts héritent de la classe NC_DirectionalCycle pour redéfinir les touches de commande par
défaut participant aux déplacement du joueur.

Notre joueur aura deux grandes instance distincts de locomotions. Une lorsqu'il est en bonne
santé et une autre lorsqu'il est dans un état critique. Ce qui nous donne droit à la mise en
place des scripts normal.gd et critical.gd. Ces deux classes héritent de CustomLocomotion.

La classe CustomLocomotion hérite à son tour de NC_BaseLocomotion. Dans cette classe, j'ai 
implémenté la logique principale du système de locomotion de base du joueur. Il faut savoir
que quelque soit les différents états que prendra celui-ci, le processus en arrière-plan,
restera inchangé. En d'autres termes, si demain le joueur passe en mode arme, les commandes
de déplacement resteront inchangés et seul l'animation sera différente.

Pour moi, le joueur peut avoir un ou plusieurs mode. Qu'est-ce que je mets dans mode? je définis
un mode du joueur comme étant un ensemble d'états que peut avoir le joueur durant ce mode.
Supposons lorsque le joueur commence son aventure, il n'a pas d'arme. Dans ce cas, on dira
qu'il est à vide. A vide représente un mode. Lorsqu'il possèdera par exemple un arc, ce sera
également un autre mode. Et dans chacun de ses modes, le joueur pourra faire des actions
spécifique.

Par example, en mode arc, le joueur peut charger et tirer son arc. Alors qu'à vide, il ne peut
pas faire cela, car il ne garde pas d'arc en ce moment. Par contre, il peut se battre à main nu.
J'espère que vous comprenez où je veux en venir. Un mode du joueur est un ensemble d'états
possible durant l'exécution de ce mode. Il peut faire telle chose dans ce mode et ne pas
pouvoir faire telle chose dans un autre mode.

C'est sur ce concept que j'ai implémenté la classe SingleMode. Elle hérite de la classe
NC_PlayerMode. Cette classe représente le joueur à vide. Le joueur lorsqu'il n'a rien garder
sur ses mains. C'est dans cette même classe que j'ai implémenté toutes les actions possibles
que le joueur peut faire un fois dans ce mode.

Et pour finir, nous avons le script player.gd qui import toutes mes implémentations afin de
faire en sorte qu'elles puissent travailler ensemble. De la détection des commandes de
l'utilisateur en passant par le mode actuel du joueur pour ensuite changé son état ou non
en fonction des possibilités qu'offre le mode active du joueur. C'est également dans ce
script que la vie globale du joueur est définie et aussi la possibilité de change le mode
en cours d'exécution.

Voilà en bref, la logique derrière le système de locomotion de base du joueur. Si je compile
tout ce bazard, on obtient le résulat que j'avais tout au début de cette vidéo.

La version Godot brut du joueur est disponible. Checker le lien d'accès dans la barre de 
description.

Ce projet est open source, vous aurez accès au source du projet à la fin de son développement
pour les currieux qui veulent comprendre comment cela a été fait en détail.

Merçi d'avoir suivi la vidéo, si vous avez des questions ou préaucupations; des idées, 
de fonctionnalitées ou d'amélioration, n'hésitez pas à le mentioner dans les commentaires.
Je ferai des vidéos au fure et à mesure sur l'avencement du développement du jeu. Pour que
vous ayez une idée de ce qui se passe sous le capeau.

N'oubliez pas de liker la vidéo, de vous abonnez et d'activer la cloche de notifications
pour ne pas raté les prochaines vidéos.

Sur ce, je vous laisse. Portez-vous bien et on se retrouve à la prochaine vidéo.
